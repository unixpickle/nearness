package nearness

import (
	"math"
	"math/rand"
)

const (
	ExploiterDecay   = 0.999999
	ExploiterEpsilon = 0.5
)

// Exploiter implements an epsilon-greedy bandit algorithm
// to exploit boards which are easy to improve while also
// exploring other boards.
type Exploiter struct {
	utility map[int]float64
}

// NewExploiter creates an Exploiter given minimum and
// maximum board sizes.
func NewExploiter(minSize, maxSize int) *Exploiter {
	res := &Exploiter{utility: map[int]float64{}}
	for i := minSize; i <= maxSize; i++ {
		res.utility[i] = 0
	}
	return res
}

// Sample gets a board size to work on.
func (e *Exploiter) Sample() int {
	if rand.Float64() < ExploiterEpsilon {
		return e.sampleRandom()
	}
	var best []int
	bestUtility := math.Inf(-1)
	for i, u := range e.utility {
		if u > bestUtility {
			bestUtility = u
			best = []int{i}
		} else if u == bestUtility {
			best = append(best, i)
		}
	}
	return best[rand.Intn(len(best))]
}

func (e *Exploiter) sampleRandom() int {
	var sizes []int
	for size := range e.utility {
		sizes = append(sizes, size)
	}
	return sizes[rand.Intn(len(sizes))]
}

// GotUtility tells the Exploiter that a given board size
// resulted in a given score improvement. This is used to
// factor into the decision making process for Sample().
func (e *Exploiter) GotUtility(size int, utility float64) {
	u := e.utility[size]
	u += math.Log(ExploiterDecay)
	u = math.Log(math.Exp(u) + utility)
	e.utility[size] = u
}
